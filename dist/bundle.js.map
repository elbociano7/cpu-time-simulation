{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://CpuTimeSimulation/webpack/universalModuleDefinition","webpack://CpuTimeSimulation/webpack/bootstrap","webpack://CpuTimeSimulation/./src/types/ProcessingUnitStatus.ts","webpack://CpuTimeSimulation/webpack/runtime/define property getters","webpack://CpuTimeSimulation/webpack/runtime/hasOwnProperty shorthand","webpack://CpuTimeSimulation/webpack/runtime/make namespace object","webpack://CpuTimeSimulation/./src/utils/Logger.ts","webpack://CpuTimeSimulation/./src/models/Simulation.ts","webpack://CpuTimeSimulation/./src/errors/ProcessingUnitError.ts","webpack://CpuTimeSimulation/./src/models/ProcessingUnit.ts","webpack://CpuTimeSimulation/./src/utils/MemoryHelper.ts","webpack://CpuTimeSimulation/./src/abstract/Dispatcher.ts","webpack://CpuTimeSimulation/./src/models/dispatchers/FCFS.ts","webpack://CpuTimeSimulation/./src/models/dispatchers/FCLS.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CpuTimeSimulation\"] = factory();\n\telse\n\t\troot[\"CpuTimeSimulation\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","export var ProcessingUnitStatus;\n(function (ProcessingUnitStatus) {\n    ProcessingUnitStatus[ProcessingUnitStatus[\"BUSY\"] = 0] = \"BUSY\";\n    ProcessingUnitStatus[ProcessingUnitStatus[\"IDLE\"] = 1] = \"IDLE\";\n    ProcessingUnitStatus[ProcessingUnitStatus[\"ERROR\"] = 2] = \"ERROR\";\n})(ProcessingUnitStatus || (ProcessingUnitStatus = {}));\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const RESET = \"\\x1b[0m\";\nconst FG_YELLOW = \"\\x1b[33m\";\nconst FG_GRAY = \"\\x1b[90m\";\nexport const Logger = {\n    customLogger: console.log,\n    prefix: '',\n    setPrefix(prefix) {\n        this.prefix = prefix;\n    },\n    log(message) {\n        this.customLogger(`${FG_YELLOW}[${this.prefix}]${RESET} ${FG_GRAY}${message}${RESET}`);\n    },\n    logHeader(message) {\n        this.customLogger(`########## ${message} ##########`);\n    }\n};\n","import { ProcessingUnitStatus } from \"../types/ProcessingUnitStatus\";\nimport { Logger } from \"../utils/Logger\";\nexport class Simulation {\n    /**\n     *\n     * @param processingUnit Processing unit to use\n     * @param tickTime Time between ticks in ms\n     * @param maxTicks Max ticks to run\n     */\n    constructor(processingUnit, tickTime, maxTicks = 0) {\n        /**\n         * List of processes and their arrival time\n         */\n        this.processList = [];\n        /**\n         * Enable logging data to console\n         */\n        this.enableLogging = false;\n        this.processingUnit = processingUnit;\n        this.tickTime = tickTime;\n        this.maxTicks = maxTicks;\n    }\n    /**\n     * Adds process to simulation. Process would arrive at the specified time.\n     * @param process Process to add\n     * @param arrivalTime Process arrival time\n     */\n    setProcess(process, arrivalTime) {\n        this.processList.push({ arrivalTime, process });\n    }\n    /**\n     * Runs the simulation\n     */\n    run() {\n        // If tick time is 0, run the simulation as fast as possible.\n        if (this.tickTime <= 0) {\n            while (true) {\n                this.tick();\n                if (this.maxTicks > 0 && this.processingUnit.time >= this.maxTicks) {\n                    break;\n                }\n            }\n        }\n        else {\n            // Otherwise run the simulation with a fixed tick time.\n            this.interval = setInterval(() => {\n                this.tick();\n                if (this.maxTicks > 0 && this.processingUnit.time >= this.maxTicks) {\n                    Logger.logHeader(`Max ticks reached: ${this.maxTicks}`);\n                    clearInterval(this.interval);\n                }\n            }, this.tickTime);\n        }\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    /**\n     * Tick execution\n     */\n    tick() {\n        const process = this.processList[this.processingUnit.time];\n        this.processList.forEach((process) => {\n            if (process.arrivalTime === this.processingUnit.time) {\n                this.processingUnit.addProcess(process.process);\n            }\n        });\n        if (this.enableLogging) {\n            Logger.logHeader(`Tick: ${this.processingUnit.time}`);\n            Logger.setPrefix(this.processingUnit.time.toString());\n        }\n        const status = this.processingUnit.tick();\n        if (status === ProcessingUnitStatus.IDLE) {\n            this.log(\"Processing unit is going idle cycle\");\n            // Checks if:\n            // 1. maxTicks is 0 (no max ticks set)\n            // 2. There are no processes in the simulation stack that will arrive \n            //    after the current tick\n            // 3. There are no processes in the dispatcher's queue\n            if (this.maxTicks === 0 &&\n                !this.processList.some((process) => process.arrivalTime >= this.processingUnit.time) &&\n                this.processingUnit.dispatcher.getQueue().length === 0) {\n                this.maxTicks = this.processingUnit.time;\n                this.log(`Stopping after ${this.maxTicks - 1} ticks`);\n            }\n        }\n    }\n    /**\n     * Log if logging is enabled\n     * @param message Message to log\n     */\n    log(message) {\n        if (this.enableLogging)\n            Logger.log(message);\n    }\n}\n","export class ProcessingUnitError extends Error {\n}\n","import { ProcessingUnitError } from \"../errors/ProcessingUnitError\";\nimport { ProcessingUnitStatus } from \"../types/ProcessingUnitStatus\";\nimport { Logger } from \"../utils/Logger\";\nimport { CopyBlock } from \"../utils/MemoryHelper\";\nexport class ProcessingUnit {\n    /**\n     * Constructs a new processing unit\n     * @param dispatcher Dispatcher to use\n     * @param pra Page replacement algorithm\n     * @param mmu Memory management unit\n     * @param memory Memory\n     * @param storage Storage\n     */\n    constructor(dispatcher, pra, mmu, memory, storage) {\n        /**\n         * Current simulation tick\n         */\n        this.time = 0;\n        this.readQueue = [];\n        this.hits = [];\n        this.misses = [];\n        /**\n         * Currently running process\n         */\n        this.currentProcess = null;\n        /**\n         * Enable logging data to console\n         */\n        this.enableLogging = false;\n        /**\n         * Custom handler for tick event\n         */\n        this.onTick = (pu) => { };\n        /**\n         * Called on process end (when process return 0)\n         * @param process Process that ended\n         */\n        this.onProcessEnd = (process, pu) => { };\n        this.dispatcher = dispatcher;\n        this.pra = pra;\n        this.mmu = mmu;\n        this.memory = memory;\n        this.storage = storage;\n    }\n    /**\n     * Runs a new process\n     * @param process Process to run\n     * @throws ProcessingUnitError if another process is already running\n     */\n    runProcess(process) {\n        if (this.enableLogging)\n            Logger.log(`Running process: '${process.name}'`);\n        if (this.currentProcess !== null) {\n            throw new ProcessingUnitError(\"Another process is already running\");\n        }\n        this.currentProcess = process;\n        this.currentProcess.run(this.getRuntimeData());\n    }\n    /**\n     * Stops the currently running process\n     * @throws ProcessingUnitError if no process is currently running\n     */\n    stopProcess() {\n        var _a, _b;\n        if (this.enableLogging)\n            Logger.log(`Stopping process: ${(_a = this.currentProcess) === null || _a === void 0 ? void 0 : _a.name}`);\n        if (this.currentProcess === null) {\n            throw new ProcessingUnitError(\"Attempted to stop null process\");\n        }\n        (_b = this.currentProcess) === null || _b === void 0 ? void 0 : _b.stop(this.getRuntimeData());\n        this.dispatcher.stopProcess(this.currentProcess);\n        this.currentProcess = null;\n    }\n    /**\n     * Drops the currently running process\n     * @throws ProcessingUnitError if no process is currently running\n     */\n    dropProcess() {\n        var _a;\n        if (this.enableLogging)\n            Logger.log(`Dropping process: '${(_a = this.currentProcess) === null || _a === void 0 ? void 0 : _a.name}'`);\n        if (this.currentProcess === null) {\n            throw new ProcessingUnitError(\"Attempted to drop null process\");\n        }\n        this.dispatcher.dropProcess(this.currentProcess);\n        this.currentProcess = null;\n    }\n    /**\n     * Adds a process to the queue\n     * @param process Process to add\n     */\n    addProcess(process) {\n        this.dispatcher.addToQueue(process);\n    }\n    /**\n     * Attempts to read data from the memory.\n     *\n     * If the data is not in the memory, it will call `replacePage` with page\n     * number from `PageReplacementAlgorithm.onMiss()` and read the data from\n     * the new page.\n     *\n     * @param address Virtual memory address to read\n     * @param handler Optional handler to be called on read\n     */\n    readData(address, handler = () => { }) {\n        const translatedAddress = this.mmu.translate(address);\n        if (translatedAddress === false) {\n            const frame = this.pra.onMiss(this.mmu, address);\n            this.log(`Memory miss at address {yellow-fg}0x${address.toString(16)}{/yellow-fg}; frame: {yellow-fg}${frame}{/yellow-fg}`);\n            const newAddress = this.replaceFrame(frame, address);\n            handler(this.memory.read(newAddress));\n            this.misses.push(address);\n        }\n        else {\n            handler(this.memory.read(translatedAddress));\n            const frame = this.pra.onHit(this.mmu, address);\n            this.log(`Memory hit at address {green-fg}0x${address.toString(16)}{/green-fg}; frame: {green-fg}${frame}{/green-fg}`);\n            this.hits.push(address);\n        }\n        this.lastRead = address;\n    }\n    /**\n     * Replaces a page in the memory with the data from the page that contains\n     * the data.\n     *\n     * @param replacedFrame Frame to be replaced\n     * @param dataAddress Address in virtual memory that contains needed data\n     * @returns New data address in physical memory\n     */\n    replaceFrame(replacedFrame, dataAddress) {\n        const { page, offset } = this.mmu.pageTable.getPageAddress(dataAddress);\n        this.mmu.pageTable.assignPageToFrame(page, replacedFrame);\n        const frameSize = this.mmu.pageTable.frameSize;\n        CopyBlock(this.storage.data, this.memory.memory, page * frameSize, replacedFrame * frameSize, frameSize);\n        return replacedFrame * frameSize + offset;\n    }\n    /**\n     * Ticks the simulation\n     * @returns PU status code\n     */\n    tick() {\n        var _a;\n        this.lastRead = undefined;\n        if (this.readQueue.length > 0) {\n            const object = this.readQueue.shift();\n            if (typeof object === \"object\") {\n                this.readData(object.address, object.handler);\n            }\n            else {\n                this.readData(object);\n            }\n        }\n        this.dispatcher.tick(this);\n        this.time++;\n        this.onTick(this);\n        if (!this.currentProcess)\n            return ProcessingUnitStatus.IDLE;\n        this.log(`Ticking process: '${this.currentProcess.name}'`);\n        const result = this.currentProcess.tick(this.getRuntimeData());\n        if (result !== null) {\n            this.log(`Process: '${(_a = this.currentProcess) === null || _a === void 0 ? void 0 : _a.name}' returned with code ${result}`);\n        }\n        if (result === 0) {\n            this.dispatcher.dropProcess(this.currentProcess);\n            this.onProcessEnd(this.currentProcess, this);\n            this.dropProcess();\n        }\n        return ProcessingUnitStatus.BUSY;\n    }\n    /**\n     * Generates runtime data for the current tick\n     * @returns Runtime data for the current tick\n     */\n    getRuntimeData() {\n        return {\n            tick: this.time,\n        };\n    }\n    /**\n     * Log if logging is enabled\n     * @param message Message to log\n     */\n    log(message) {\n        if (this.enableLogging) {\n            Logger.log(message);\n        }\n    }\n}\n","export const CopyBlock = (source, destination, sourceAddress, destinationAddress, size) => {\n    var _a;\n    for (let i = 0; i < size; i++) {\n        destination.set(destinationAddress + i, (_a = source.get(sourceAddress + i)) !== null && _a !== void 0 ? _a : 0);\n    }\n};\n","export class Dispatcher {\n}\n","import { Dispatcher } from \"../../abstract/Dispatcher\";\nexport class FCFS extends Dispatcher {\n    constructor() {\n        super(...arguments);\n        this.queue = [];\n        this.busy = false;\n    }\n    addToQueue(process) {\n        this.queue.push(process);\n    }\n    tick(processingUnit) {\n        if (!this.busy) {\n            const process = this.queue.shift();\n            if (process) {\n                this.busy = true;\n                processingUnit.runProcess(process);\n            }\n        }\n    }\n    dropProcess(process) {\n        this.busy = false;\n    }\n    stopProcess(process) {\n        this.queue.push(process);\n        this.busy = false;\n    }\n    getQueue() {\n        return this.queue;\n    }\n}\n","import { Dispatcher } from \"../../abstract/Dispatcher\";\nexport class FCLS extends Dispatcher {\n    constructor() {\n        super(...arguments);\n        this.queue = [];\n        this.busy = false;\n    }\n    addToQueue(process) {\n        this.queue.push(process);\n    }\n    tick(processingUnit) {\n        if (!this.busy) {\n            const process = this.queue.pop();\n            if (process) {\n                this.busy = true;\n                processingUnit.runProcess(process);\n            }\n        }\n    }\n    dropProcess(process) {\n        this.busy = false;\n    }\n    stopProcess(process) {\n        this.queue.push(process);\n        this.busy = false;\n    }\n    getQueue() {\n        return this.queue;\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","self","ProcessingUnitStatus","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","RESET","Logger","customLogger","console","log","prefix","setPrefix","this","message","logHeader","Simulation","constructor","processingUnit","tickTime","maxTicks","processList","enableLogging","setProcess","process","arrivalTime","push","run","tick","time","interval","setInterval","clearInterval","stop","forEach","addProcess","toString","IDLE","some","dispatcher","getQueue","length","ProcessingUnitError","Error","ProcessingUnit","pra","mmu","memory","storage","readQueue","hits","misses","currentProcess","onTick","pu","onProcessEnd","runProcess","name","getRuntimeData","stopProcess","_a","_b","dropProcess","addToQueue","readData","address","handler","translatedAddress","translate","frame","onMiss","newAddress","replaceFrame","read","onHit","lastRead","replacedFrame","dataAddress","page","offset","pageTable","getPageAddress","assignPageToFrame","frameSize","source","destination","sourceAddress","destinationAddress","size","i","set","CopyBlock","data","undefined","object","shift","result","BUSY","Dispatcher","FCFS","super","arguments","queue","busy","FCLS","pop"],"sourceRoot":""}